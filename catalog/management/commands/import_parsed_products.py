from __future__ import annotations

import json
from datetime import date
from decimal import Decimal
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional

from django.core.management.base import BaseCommand, CommandError, CommandParser
from django.db import transaction
from django.utils import timezone

from catalog.models import (
    Category,
    DosageForm,
    Lot,
    Product,
    PurchaseOrder,
    StockMovement,
    Supplier,
)


class Command(BaseCommand):
    help = 'Import normalized products generated by parse_product_feed into the database.'

    def add_arguments(self, parser: CommandParser) -> None:
        parser.add_argument('input_file', type=str, help='Path to the parsed JSON file.')
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Parse and validate without persisting any change.',
        )

    def handle(self, *args, **options) -> None:
        input_path = Path(options['input_file'])
        dry_run = options['dry_run']

        if not input_path.exists():
            raise CommandError(f"Input file {input_path} does not exist.")

        with input_path.open('r', encoding='utf-8-sig') as stream:
            try:
                payload = json.load(stream)
            except json.JSONDecodeError as exc:
                raise CommandError(f'Failed to parse JSON file: {exc}') from exc

        products = payload.get('products', [])
        if not isinstance(products, list):
            raise CommandError('The parsed JSON does not contain a "products" array.')

        errors: List[str] = []
        created = 0
        updated = 0

        context_manager = transaction.atomic() if not dry_run else _nullcontext()
        with context_manager:
            for item in products:
                if item.get('errors'):
                    errors.append(
                        f"Skipping product {item.get('source_id')} due to prior parsing errors: "
                        f"{' | '.join(item['errors'])}"
                    )
                    continue

                try:
                    result = self._import_single_product(item, dry_run=dry_run)
                    if result == 'created':
                        created += 1
                    elif result == 'updated':
                        updated += 1
                except Exception as exc:
                    errors.append(
                        f"Failed to import product {item.get('source_id')} ({item.get('name')}): {exc}"
                    )

        for error in errors:
            self.stderr.write(self.style.WARNING(error))

        summary = f'Import finished: {created} created, {updated} updated.'
        if errors:
            summary += f' {len(errors)} issues encountered.'
        if dry_run:
            summary += ' (dry-run, no data committed)'
        self.stdout.write(self.style.SUCCESS(summary))

    def _import_single_product(self, item: Dict[str, Any], *, dry_run: bool) -> str:
        category_name = item.get('category_name')
        dosage_form_name = item.get('dosage_form_name')

        if not category_name:
            raise ValueError('Missing category_name')
        if not dosage_form_name:
            raise ValueError('Missing dosage_form_name')

        category, _ = Category.objects.get_or_create(
            name=category_name,
            defaults={'code': category_name[:50]},
        )
        dosage_form, _ = DosageForm.objects.get_or_create(name=dosage_form_name)

        barcode = item.get('barcode')
        if not barcode:
            raise ValueError('Missing barcode')

        supplier_name = item.get('supplier_name')
        supplier = None
        if supplier_name:
            supplier, _ = Supplier.objects.get_or_create(name=supplier_name)

        # Créer ou mettre à jour le produit (sans stock_quantity, expiration_date, purchase_price, sale_price)
        product_defaults = {
            'name': item.get('name', ''),
            'category': category,
            'dosage_form': dosage_form,
            'supplier': supplier,
            'stock_threshold': item.get('stock_alert') or 0,
            'notes': item.get('note') or '',
        }

        product, product_created = Product.objects.update_or_create(
            barcode=barcode,
            defaults=product_defaults,
        )

        # Si le produit a une quantité et une date d'expiration, créer un lot
        quantity = item.get('quantity') or 0
        expiration_date_str = item.get('expiration_date')
        purchase_price = self._decimal_or_default(item.get('cost'))
        sale_price = self._decimal_or_default(item.get('price'))

        if quantity > 0 and expiration_date_str and not dry_run:
            # Créer une commande d'achat par défaut pour l'import
            # Utiliser le supplier du produit ou créer un supplier par défaut
            import_supplier = supplier
            if not import_supplier:
                import_supplier, _ = Supplier.objects.get_or_create(
                    name='Import automatique',
                    defaults={'notes': 'Fournisseur créé automatiquement lors de l\'import'}
                )
            
            purchase_order, _ = PurchaseOrder.objects.get_or_create(
                supplier=import_supplier,
                status=PurchaseOrder.Status.RECEIVED,
                defaults={
                    'order_date': timezone.now(),
                    'receipt_date': timezone.now(),
                    'notes': 'Import automatique depuis parsed feed',
                },
            )

            # Parser la date d'expiration
            try:
                expiration_date = date.fromisoformat(expiration_date_str) if expiration_date_str else None
            except (ValueError, TypeError):
                expiration_date = None

            if expiration_date:
                # Créer le lot
                lot = Lot.objects.create(
                    purchase_order=purchase_order,
                    product=product,
                    quantity=quantity,
                    remaining_quantity=quantity,
                    expiration_date=expiration_date,
                    purchase_price=purchase_price,
                    sale_price=sale_price,
                    batch_number=f'IMPORT-{barcode}',
                )

                # Créer le mouvement de stock
                StockMovement.objects.create(
                    lot=lot,
                    movement_type=StockMovement.MovementType.IN,
                    quantity=quantity,
                    source='Initial import',
                    comment='Initial stock from parsed feed',
                )

        return 'created' if product_created else 'updated'

    @staticmethod
    def _decimal_or_default(value: Optional[str]) -> Decimal:
        if value is None or value == '':
            return Decimal('0')
        return Decimal(str(value))


class _nullcontext:
    def __enter__(self):
        return None

    def __exit__(self, exc_type, exc_val, exc_tb):
        return False

