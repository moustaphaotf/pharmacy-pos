from __future__ import annotations

import json
from decimal import Decimal
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional

from django.core.management.base import BaseCommand, CommandError, CommandParser
from django.db import transaction

from catalog.models import Category, DosageForm, Product, StockMovement, Supplier


class Command(BaseCommand):
    help = 'Import normalized products generated by parse_product_feed into the database.'

    def add_arguments(self, parser: CommandParser) -> None:
        parser.add_argument('input_file', type=str, help='Path to the parsed JSON file.')
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Parse and validate without persisting any change.',
        )

    def handle(self, *args, **options) -> None:
        input_path = Path(options['input_file'])
        dry_run = options['dry_run']

        if not input_path.exists():
            raise CommandError(f"Input file {input_path} does not exist.")

        with input_path.open('r', encoding='utf-8-sig') as stream:
            try:
                payload = json.load(stream)
            except json.JSONDecodeError as exc:
                raise CommandError(f'Failed to parse JSON file: {exc}') from exc

        products = payload.get('products', [])
        if not isinstance(products, list):
            raise CommandError('The parsed JSON does not contain a "products" array.')

        errors: List[str] = []
        created = 0
        updated = 0

        context_manager = transaction.atomic() if not dry_run else _nullcontext()
        with context_manager:
            for item in products:
                if item.get('errors'):
                    errors.append(
                        f"Skipping product {item.get('source_id')} due to prior parsing errors: "
                        f"{' | '.join(item['errors'])}"
                    )
                    continue

                try:
                    result = self._import_single_product(item, dry_run=dry_run)
                    if result == 'created':
                        created += 1
                    elif result == 'updated':
                        updated += 1
                except Exception as exc:
                    errors.append(
                        f"Failed to import product {item.get('source_id')} ({item.get('name')}): {exc}"
                    )

        for error in errors:
            self.stderr.write(self.style.WARNING(error))

        summary = f'Import finished: {created} created, {updated} updated.'
        if errors:
            summary += f' {len(errors)} issues encountered.'
        if dry_run:
            summary += ' (dry-run, no data committed)'
        self.stdout.write(self.style.SUCCESS(summary))

    def _import_single_product(self, item: Dict[str, Any], *, dry_run: bool) -> str:
        category_name = item.get('category_name')
        dosage_form_name = item.get('dosage_form_name')

        if not category_name:
            raise ValueError('Missing category_name')
        if not dosage_form_name:
            raise ValueError('Missing dosage_form_name')

        category, _ = Category.objects.get_or_create(
            name=category_name,
            defaults={'code': category_name[:50]},
        )
        dosage_form, _ = DosageForm.objects.get_or_create(name=dosage_form_name)

        barcode = item.get('barcode')
        if not barcode:
            raise ValueError('Missing barcode')

        supplier_name = item.get('supplier_name')
        supplier = None
        if supplier_name:
            supplier, _ = Supplier.objects.get_or_create(name=supplier_name)

        product_defaults = {
            'name': item.get('name', ''),
            'category': category,
            'dosage_form': dosage_form,
            'supplier': supplier,
            'purchase_price': self._decimal_or_default(item.get('cost')),
            'sale_price': self._decimal_or_default(item.get('price')),
            'stock_quantity': item.get('quantity') or 0,
            'stock_threshold': item.get('stock_alert') or 0,
            'expiration_date': item.get('expiration_date') or None,
            'notes': item.get('note') or '',
        }

        product, created = Product.objects.update_or_create(
            barcode=barcode,
            defaults=product_defaults,
        )

        if created and not dry_run:
            StockMovement.objects.create(
                product=product,
                movement_type=StockMovement.MovementType.ADJUSTMENT,
                quantity=product.stock_quantity,
                source='Initial import',
                comment='Initial stock from parsed feed',
            )

        return 'created' if created else 'updated'

    @staticmethod
    def _decimal_or_default(value: Optional[str]) -> Decimal:
        if value is None or value == '':
            return Decimal('0')
        return Decimal(str(value))


class _nullcontext:
    def __enter__(self):
        return None

    def __exit__(self, exc_type, exc_val, exc_tb):
        return False

